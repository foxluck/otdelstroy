WbsData = function() {
	var params = {};
	return {
		set: function (obj) {
			$.extend(params, obj);
		},
		get: function (name, defaultValue) {
			if( name == null ) return params;
			return params[name] || defaultValue || null;
		}
	}
}();

function setCookie(cookieName, cookieValue, nDays) {
	var today = new Date();
	var expire = new Date();
	if (nDays==null || nDays==0) nDays=1;
	expire.setTime(today.getTime() + 3600000*24*nDays);
	document.cookie = cookieName+"="+escape(cookieValue)
	+ ";expires="+expire.toGMTString();
}

function newClass(parent, prop) {
	  // Dynamically create class constructor.
	  var clazz = function() {
	    // Stupid JS need exactly one "operator new" calling for parent
	    // constructor just after class definition.
	    if (clazz.preparing) return delete(clazz.preparing);
	    // Call custom constructor.
	    if (clazz.constr) {
	      this.constructor = clazz; // we need it!
	      clazz.constr.apply(this, arguments);
	    }
	  }
	  clazz.prototype = {}; // no prototype by default
	  if (parent) {
	    parent.preparing = true;
	    clazz.prototype = new parent;
	    clazz.prototype.constructor = parent;
	    clazz.constr = parent; // BY DEFAULT - parent constructor
	  }
	  if (prop) {
	    var cname = "constructor";
	    for (var k in prop) {
	      if (k != cname) clazz.prototype[k] = prop[k];
	    }
	    if (prop[cname] && prop[cname] != Object)
	      clazz.constr = prop[cname];
	  }
	  clazz.prototype.superclass = function() {return this.constructor.prototype};
	  return clazz;
}

Function.prototype.bind = function(scope, object) {	
	if (object)
		scope.self = object;
	
	var __method = this;
	return function() {
		return __method.apply(scope, arguments);
	}
}

function addHandler(element, event, action, scope){
	if (scope) {
		action = action.bind(scope);
	}
	
	if(document.addEventListener) element.addEventListener(event, action, null);
	else if(document.attachEvent) element.attachEvent('on' + event,action);
	else element['on'+event] = action;
}

function createDiv(className) {
	return createElem("div", className);
}

function createElem(tag, className, attributes) {
	var elem = document.createElement(tag);
	$(elem).addClass(className);
	if (attributes) {
		$(elem).attr(attributes);
	}
	return elem;	
}

function htmlspecialchars(str) {
	if (str == null || typeof str != 'string' || str.length == 0) {
		return str;
	}
	return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
}

$().ajaxComplete(function(request, settings){
	if (settings.status == 200) {
		try {
			var response = eval("(" + settings.responseText + ")");
			if (response.errorCode == 'SESSION_TIMEOUT') {
				if (window && window.parent) {
					var d = window.parent.document;
				} else {
					var d = document;
				}
				d.location.href = response.redirectUrl;
			}
			if ( response.status == 'ERR' && !response.hide &&  typeof(response.error) == "string") {
				if (document.hideError) {
					document.hideError = false;
				} else {
					alert(response.error);
				}
			}
		} catch (e) {
			
		}
	}
});
 
(function(){

WBS = {
    getDom : function(el){
        if(!el || !document){
            return null;
        }
        return el.dom ? el.dom : (typeof el == 'string' ? document.getElementById(el) : el);
    }
};
WBS.util = {};
WBS.isReady = true;

WBS.apply = function(o, c, defaults){
    if(defaults){
        // no "this" reference for friendly out of scope calls
        WBS.apply(o, defaults);
    }
    if(o && c && typeof c == 'object'){
        for(var p in c){
            o[p] = c[p];
        }
    }
    return o;
};
WBS.applyIf = function(o,c){
	if(o&&c){
		for(var p in c){
			if(typeof o[p]=="undefined"){
				o[p]=c[p]
			}
		}
	}
	return o
};

(function(){
    var idSeed = 0;
    var ua = navigator.userAgent.toLowerCase();

    var isStrict = document.compatMode == "CSS1Compat",
        isOpera = ua.indexOf("opera") > -1,
        isSafari = (/webkit|khtml/).test(ua),
        isSafari3 = isSafari && ua.indexOf('webkit/5') != -1,
        isIE = !isOpera && ua.indexOf("msie") > -1,
        isIE7 = !isOpera && ua.indexOf("msie 7") > -1,
        isGecko = !isSafari && ua.indexOf("gecko") > -1,
        isGecko3 = !isSafari && ua.indexOf("rv:1.9") > -1,
        isBorderBox = isIE && !isStrict,
        isWindows = (ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1),
        isMac = (ua.indexOf("macintosh") != -1 || ua.indexOf("mac os x") != -1),
        isAir = (ua.indexOf("adobeair") != -1),
        isLinux = (ua.indexOf("linux") != -1),
        isSecure = window.location.href.toLowerCase().indexOf("https") === 0;

    WBS.apply(WBS, {
        isOpera : isOpera,
        isSafari : isSafari,
        isSafari3 : isSafari3,
        isSafari2 : isSafari && !isSafari3,
        isIE : isIE,
        isIE6 : isIE && !isIE7,
        isIE7 : isIE7,
        isGecko : isGecko,
        isGecko2 : isGecko && !isGecko3,
        isGecko3 : isGecko3,
        isBorderBox : isBorderBox,
        isLinux : isLinux,
        isWindows : isWindows,
        isMac : isMac,
        isAir : isAir});
})();

/**
 * @class WBS.util.Observable
 * Abstract base class that provides a common interface for publishing events. Subclasses are expected to
 * to have a property "events" with all the events defined.<br>
 * For example:
 * <pre><code>
 Employee = function(name){
    this.name = name;
    this.addEvents({
        "fired" : true,
        "quit" : true
    });
 }
 WBS.extend(Employee, WBS.util.Observable);
</code></pre>
 */
WBS.util.Observable = function(){
    /**
     * @cfg {Object} listeners A config object containing one or more event handlers to be added to this
     * object during initialization.  This should be a valid listeners config object as specified in the
     * {@link #addListener} example for attaching multiple handlers at once.
     */
    if(this.listeners){
        this.on(this.listeners);
        delete this.listeners;
    }
};
WbsObservable = WBS.util.Observable;

WBS.util.Observable.prototype = {
    /**
     * Fires the specified event with the passed parameters (minus the event name).
     * @param {String} eventName
     * @param {Object...} args Variable number of parameters are passed to handlers
     * @return {Boolean} returns false if any of the handlers return false otherwise it returns true
     */
    fireEvent : function(){
        if(this.eventsSuspended !== true){
            var ce = this.events[arguments[0].toLowerCase()];
            if(typeof ce == "object"){
                return ce.fire.apply(ce, Array.prototype.slice.call(arguments, 1));
            }
        }
        return true;
    },

    // private
    filterOptRe : /^(?:scope|delay|buffer|single)$/,

    /**
     * Appends an event handler to this component
     * @param {String}   eventName The type of event to listen for
     * @param {Function} handler The method the event invokes
     * @param {Object}   scope (optional) The scope in which to execute the handler
     * function. The handler function's "this" context.
     * @param {Object}   options (optional) An object containing handler configuration
     * properties. This may contain any of the following properties:<ul>
     * <li><b>scope</b> : Object<p class="sub-desc">The scope in which to execute the handler function. The handler function's "this" context.</p></li>
     * <li><b>delay</b> : Number<p class="sub-desc">The number of milliseconds to delay the invocation of the handler after the event fires.</p></li>
     * <li><b>single</b> : Boolean<p class="sub-desc">True to add a handler to handle just the next firing of the event, and then remove itself.</p></li>
     * <li><b>buffer</b> : Number<p class="sub-desc">Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed
     * by the specified number of milliseconds. If the event fires again within that time, the original
     * handler is <em>not</em> invoked, but the new handler is scheduled in its place.</p></li>
     * </ul><br>
     * <p>
     * <b>Combining Options</b><br>
     * Using the options argument, it is possible to combine different types of listeners:<br>
     * <br>
     * A normalized, delayed, one-time listener that auto stops the event and passes a custom argument (forumId)
     * <pre><code>
el.on('click', this.onClick, this, {
    single: true,
    delay: 100,
    forumId: 4
});</code></pre>
     * <p>
     * <b>Attaching multiple handlers in 1 call</b><br>
      * The method also allows for a single argument to be passed which is a config object containing properties
     * which specify multiple handlers.
     * <p>
     * <pre><code>
foo.on({
    'click' : {
        fn: this.onClick,
        scope: this,
        delay: 100
    },
    'mouseover' : {
        fn: this.onMouseOver,
        scope: this
    },
    'mouseout' : {
        fn: this.onMouseOut,
        scope: this
    }
});</code></pre>
     * <p>
     * Or a shorthand syntax:<br>
     * <pre><code>
foo.on({
    'click' : this.onClick,
    'mouseover' : this.onMouseOver,
    'mouseout' : this.onMouseOut,
     scope: this
});</code></pre>
     */
    addListener : function(eventName, fn, scope, o){
        if(typeof eventName == "object"){
            o = eventName;
            for(var e in o){
                if(this.filterOptRe.test(e)){
                    continue;
                }
                if(typeof o[e] == "function"){
                    // shared options
                    this.addListener(e, o[e], o.scope,  o);
                }else{
                    // individual options
                    this.addListener(e, o[e].fn, o[e].scope, o[e]);
                }
            }
            return;
        }
        o = (!o || typeof o == "boolean") ? {} : o;
        eventName = eventName.toLowerCase();
        var ce = this.events[eventName] || true;
        if(typeof ce == "boolean"){
            ce = new WBS.util.Event(this, eventName);
            this.events[eventName] = ce;
        }
        ce.addListener(fn, scope, o);
    },

    /**
     * Removes a listener
     * @param {String}   eventName     The type of event to listen for
     * @param {Function} handler        The handler to remove
     * @param {Object}   scope  (optional) The scope (this object) for the handler
     */
    removeListener : function(eventName, fn, scope){
        var ce = this.events[eventName.toLowerCase()];
        if(typeof ce == "object"){
            ce.removeListener(fn, scope);
        }
    },

    /**
     * Removes all listeners for this object
     */
    purgeListeners : function(){
        for(var evt in this.events){
            if(typeof this.events[evt] == "object"){
                 this.events[evt].clearListeners();
            }
        }
    },

    /**
     * Relays selected events from the specified Observable as if the events were fired by <tt><b>this</b></tt>.
     * @param {Object} o The Observable whose events this object is to relay.
     * @param {Array} events Array of event names to relay.
     */
    relayEvents : function(o, events){
        var createHandler = function(ename){
            return function(){
                return this.fireEvent.apply(this, WBS.combine(ename, Array.prototype.slice.call(arguments, 0)));
            };
        };
        for(var i = 0, len = events.length; i < len; i++){
            var ename = events[i];
            if(!this.events[ename]){ this.events[ename] = true; };
            o.on(ename, createHandler(ename), this);
        }
    },

    /**
     * Used to define events on this Observable
     * @param {Object} object The object with the events defined
     */
    addEvents : function(o){
        if(!this.events){
            this.events = {};
        }
        if(typeof o == 'string'){
            for(var i = 0, a = arguments, v; v = a[i]; i++){
                if(!this.events[a[i]]){
                    this.events[a[i]] = true;
                }
            }
        }else{
            WBS.applyIf(this.events, o);
        }
    },

    /**
     * Checks to see if this object has any listeners for a specified event
     * @param {String} eventName The name of the event to check for
     * @return {Boolean} True if the event is being listened for, else false
     */
    hasListener : function(eventName){
        var e = this.events[eventName];
        return typeof e == "object" && e.listeners.length > 0;
    },

    /**
     * Suspend the firing of all events. (see {@link #resumeEvents})
     */
    suspendEvents : function(){
        this.eventsSuspended = true;
    },

    /**
     * Resume firing events. (see {@link #suspendEvents})
     */
    resumeEvents : function(){
        this.eventsSuspended = false;
    },

    // these are considered experimental
    // allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
    // private
    getMethodEvent : function(method){
        if(!this.methodEvents){
            this.methodEvents = {};
        }
        var e = this.methodEvents[method];
        if(!e){
            e = {};
            this.methodEvents[method] = e;

            e.originalFn = this[method];
            e.methodName = method;
            e.before = [];
            e.after = [];


            var returnValue, v, cancel;
            var obj = this;

            var makeCall = function(fn, scope, args){
                if((v = fn.apply(scope || obj, args)) !== undefined){
                    if(typeof v === 'object'){
                        if(v.returnValue !== undefined){
                            returnValue = v.returnValue;
                        }else{
                            returnValue = v;
                        }
                        if(v.cancel === true){
                            cancel = true;
                        }
                    }else if(v === false){
                        cancel = true;
                    }else {
                        returnValue = v;
                    }
                }
            }

            this[method] = function(){
                returnValue = v = undefined; cancel = false;
                var args = Array.prototype.slice.call(arguments, 0);
                for(var i = 0, len = e.before.length; i < len; i++){
                    makeCall(e.before[i].fn, e.before[i].scope, args);
                    if(cancel){
                        return returnValue;
                    }
                }

                if((v = e.originalFn.apply(obj, args)) !== undefined){
                    returnValue = v;
                }

                for(var i = 0, len = e.after.length; i < len; i++){
                    makeCall(e.after[i].fn, e.after[i].scope, args);
                    if(cancel){
                        return returnValue;
                    }
                }
                return returnValue;
            };
        }
        return e;
    },

    // adds an "interceptor" called before the original method
    beforeMethod : function(method, fn, scope){
        var e = this.getMethodEvent(method);
        e.before.push({fn: fn, scope: scope});
    },

    // adds a "sequence" called after the original method
    afterMethod : function(method, fn, scope){
        var e = this.getMethodEvent(method);
        e.after.push({fn: fn, scope: scope});
    },

    removeMethodListener : function(method, fn, scope){
        var e = this.getMethodEvent(method);
        for(var i = 0, len = e.before.length; i < len; i++){
            if(e.before[i].fn == fn && e.before[i].scope == scope){
                e.before.splice(i, 1);
                return;
            }
        }
        for(var i = 0, len = e.after.length; i < len; i++){
            if(e.after[i].fn == fn && e.after[i].scope == scope){
                e.after.splice(i, 1);
                return;
            }
        }
    }
};
/**
 * Appends an event handler to this element (shorthand for addListener)
 * @param {String}   eventName     The type of event to listen for
 * @param {Function} handler        The method the event invokes
 * @param {Object}   scope (optional) The scope in which to execute the handler
 * function. The handler function's "this" context.
 * @param {Object}   options  (optional)
 * @method
 */
WBS.util.Observable.prototype.on = WBS.util.Observable.prototype.addListener;
/**
 * Removes a listener (shorthand for removeListener)
 * @param {String}   eventName     The type of event to listen for
 * @param {Function} handler        The handler to remove
 * @param {Object}   scope  (optional) The scope (this object) for the handler
 * @method
 */
WBS.util.Observable.prototype.un = WBS.util.Observable.prototype.removeListener;

/**
 * Starts capture on the specified Observable. All events will be passed
 * to the supplied function with the event name + standard signature of the event
 * <b>before</b> the event is fired. If the supplied function returns false,
 * the event will not fire.
 * @param {Observable} o The Observable to capture
 * @param {Function} fn The function to call
 * @param {Object} scope (optional) The scope (this object) for the fn
 * @static
 */
WBS.util.Observable.capture = function(o, fn, scope){
    o.fireEvent = o.fireEvent.createInterceptor(fn, scope);
};

/**
 * Removes <b>all</b> added captures from the Observable.
 * @param {Observable} o The Observable to release
 * @static
 */
WBS.util.Observable.releaseCapture = function(o){
    o.fireEvent = WBS.util.Observable.prototype.fireEvent;
};

(function(){

    var createBuffered = function(h, o, scope){
        var task = new WBS.util.DelayedTask();
        return function(){
            task.delay(o.buffer, h, scope, Array.prototype.slice.call(arguments, 0));
        };
    };

    var createSingle = function(h, e, fn, scope){
        return function(){
            e.removeListener(fn, scope);
            return h.apply(scope, arguments);
        };
    };

    var createDelayed = function(h, o, scope){
        return function(){
            var args = Array.prototype.slice.call(arguments, 0);
            setTimeout(function(){
                h.apply(scope, args);
            }, o.delay || 10);
        };
    };

    WBS.util.Event = function(obj, name){
        this.name = name;
        this.obj = obj;
        this.listeners = [];
    };

    WBS.util.Event.prototype = {
        addListener : function(fn, scope, options){
            scope = scope || this.obj;
            if(!this.isListening(fn, scope)){
                var l = this.createListener(fn, scope, options);
                if(!this.firing){
                    this.listeners.push(l);
                }else{ // if we are currently firing this event, don't disturb the listener loop
                    this.listeners = this.listeners.slice(0);
                    this.listeners.push(l);
                }
            }
        },

        createListener : function(fn, scope, o){
            o = o || {};
            scope = scope || this.obj;
            var l = {fn: fn, scope: scope, options: o};
            var h = fn;
            if(o.delay){
                h = createDelayed(h, o, scope);
            }
            if(o.single){
                h = createSingle(h, this, fn, scope);
            }
            if(o.buffer){
                h = createBuffered(h, o, scope);
            }
            l.fireFn = h;
            return l;
        },

        findListener : function(fn, scope){
            scope = scope || this.obj;
            var ls = this.listeners;
            for(var i = 0, len = ls.length; i < len; i++){
                var l = ls[i];
                if(l.fn == fn && l.scope == scope){
                    return i;
                }
            }
            return -1;
        },

        isListening : function(fn, scope){
            return this.findListener(fn, scope) != -1;
        },

        removeListener : function(fn, scope){
            var index;
            if((index = this.findListener(fn, scope)) != -1){
                if(!this.firing){
                    this.listeners.splice(index, 1);
                }else{
                    this.listeners = this.listeners.slice(0);
                    this.listeners.splice(index, 1);
                }
                return true;
            }
            return false;
        },

        clearListeners : function(){
            this.listeners = [];
        },

        fire : function(){
            var ls = this.listeners, scope, len = ls.length;
            if(len > 0){
                this.firing = true;
                var args = Array.prototype.slice.call(arguments, 0);
                for(var i = 0; i < len; i++){
                    var l = ls[i];
                    if(l.fireFn.apply(l.scope||this.obj||window, arguments) === false){
                        this.firing = false;
                        return false;
                    }
                }
                this.firing = false;
            }
            return true;
        }
    };
})();



/*
 * WBS JS Library 2.2
 * Copyright(c) 2006-2008, WBS JS, LLC.
 * licensing@WBSjs.com
 *
 * http://WBSjs.com/license
 */

/**
 * @class WBS.History
 * @extends WBS.util.Observable
 * History management component that allows you to register arbitrary tokens that signify application
 * history state on navigation actions.  You can then handle the history {@link #change} event in order
 * to reset your application UI to the appropriate state when the user navigates forward or backward through
 * the browser history stack.
 * @singleton
 */
WBS.History = (function () {
    var iframe, hiddenField;
    var ready = false;
    var currentToken;

    function getHash() {
        var href = top.location.href, i = href.indexOf("#");
        return i >= 0 ? href.substr(i + 1) : null;
    }

    function doSave() {
        hiddenField.value = currentToken;
    }

    function handleStateChange(token) {
        currentToken = token;
        WBS.History.fireEvent('change', token);
    }

    function updateIFrame (token) {
        var html = ['<html><body><div id="state">',token,'</div></body></html>'].join('');
        try {
            var doc = iframe.contentWindow.document;
            doc.open();
            doc.write(html);
            doc.close();
            return true;
        } catch (e) {
            return false;
        }
    }

    function checkIFrame() {
        if (!iframe.contentWindow || !iframe.contentWindow.document) {
            setTimeout(checkIFrame, 10);
            return;
        }

        var doc = iframe.contentWindow.document;
        var elem = doc.getElementById("state");
        var token = elem ? elem.innerText : null;

        var hash = getHash();

        setInterval(function () {

            doc = iframe.contentWindow.document;
            elem = doc.getElementById("state");

            var newtoken = elem ? elem.innerText : null;

            var newHash = getHash();

            if (newtoken !== token) {
                token = newtoken;
                handleStateChange(token);
                top.location.hash = token;
                hash = token;
                doSave();
            } else if (newHash !== hash) {
                hash = newHash;
                updateIFrame(newHash);
            }

        }, 50);

        ready = true;

        WBS.History.fireEvent('ready', WBS.History);
    }

    function startUp() {
        currentToken = hiddenField.value;

        if (WBS.isIE) {
            checkIFrame();
        } else {
            var hash = getHash();
            setInterval(function () {
                var newHash = getHash();
                if (newHash !== hash) {
                    hash = newHash;
                    handleStateChange(hash);
                    doSave();
                }
            }, 50);
            ready = true;
            WBS.History.fireEvent('ready', WBS.History);
        }
    }

    return {
        /**
         * The id of the hidden field required for storing the current history token.
         * @type String
         * @property
         */
        fieldId: 'x-history-field',
        /**
         * The id of the iframe required by IE to manage the history stack.
         * @type String
         * @property
         */
        iframeId: 'x-history-frame',
        
        events:{},

        /**
         * Initialize the global History instance.
         * @param {Boolean} onReady (optional) A callback function that will be called once the history
         * component is fully initialized.
         * @param {Object} scope (optional) The callback scope
         */
        init: function (onReady, scope) {
            if(ready) {
                WBS.callback(onReady, scope, [this]);
                return;
            }
            if(!WBS.isReady){
                WBS.onReady(function(){
                    WBS.History.init(onReady, scope);
                });
                return;
            }
            hiddenField = WBS.getDom(WBS.History.fieldId);
			if (WBS.isIE) {
                iframe = WBS.getDom(WBS.History.iframeId);
            }
            this.addEvents('ready', 'change');
            if(onReady){
                this.on('ready', onReady, scope, {single:true});
            }
            startUp();
        },

        /**
         * Add a new token to the history stack. This can be any arbitrary value, although it would
         * commonly be the concatenation of a component id and another id marking the specifc history
         * state of that component.  Example usage:
         * <pre><code>
// Handle tab changes on a TabPanel
tabPanel.on('tabchange', function(tabPanel, tab){
    WBS.History.add(tabPanel.id + ':' + tab.id);
});
</code></pre>
         * @param {String} token The value that defines a particular application-specific history state
         * @param {Boolean} preventDuplicates When true, if the passed token matches the current token
         * it will not save a new history step. Set to false if the same state can be saved more than once
         * at the same history stack location (defaults to true).
         */
        add: function (token, preventDup) {
            if(preventDup !== false){
                if(this.getToken() == token){
                    return true;
                }
            }
            if (WBS.isIE) {
                return updateIFrame(token);
            } else {
                top.location.hash = token;
                return true;
            }
        },

        /**
         * Programmatically steps back one step in browser history (equivalent to the user pressing the Back button).
         */
        back: function(){
            history.go(-1);
        },

        /**
         * Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button).
         */
        forward: function(){
            history.go(1);
        },

        /**
         * Retrieves the currently-active history token.
         * @return {String} The token
         */
        getToken: function() {
            return ready ? currentToken : getHash();
        },
		_getToken: function() {
            return getHash();
        }
    };
})();
WBS.apply(WBS.History, new WBS.util.Observable());

})();

WbsObservable = newClass(WBS.util.Observable, {});

WbsApplication = newClass(null, {
	contructor: function() {
	},
		
	startLoading: function() {
		if (window.parent && window.parent.showHideLoading)
  		window.parent.showHideLoading(true);
	},
		
	finishLoading: function() {
		if (window.parent && window.parent.showHideLoading)
  		window.parent.showHideLoading(false);
	},
	
	openSubframe: function(url, oldUrl) {
  	this.closeSubframe();
  	
  	if (oldUrl)
  		url = this.getOldUrl(url);
  	
  	var iframe = createElem("iframe", "subframe");
  	iframe.style.width = "100%";
  	iframe.style.height = "100%";
  	iframe.frameBorder = "no";
  	iframe.setAttribute("SCROLLING", "NO");
  	this.startLoading();
  	addHandler(iframe, "load", this.finishLoading, this);
  	//iframe.onload = function() {alert("HELLO"); }
  	
  	var contentBlock = document.getElementById("screen-content-block");
  	contentBlock.insertBefore (iframe, contentBlock.firstChild);
  	
  	if (Ext.isOpera) {
  		iframe.location.href = url;
  	} else {
  		iframe.src = url;
  	}
  	this.subFrame = iframe;
  },
  
  closeSubframe: function() {
  	if (this.subFrame) {
  		this.subFrame.parentNode.removeChild(this.subFrame);
  		this.subFrame = null;
  	}
  },
  
  getOldUrl: function(url) {
  	return "../html/" + url;
  }
});


function getAbsolutePos(el)
{
	var r = { x: el.offsetLeft, y: el.offsetTop };
	if (el.parentNode && el.parentNode.scrollTop)
		r.y -= el.parentNode.scrollTop;
	if (el.offsetParent)
		{
		var tmp = getAbsolutePos(el.offsetParent);
		r.x += tmp.x;
		r.y += tmp.y;
		}
	return r;
}

WbsPopwindow = newClass (WbsObservable, {
	
	constructor: function (config) {
		if (!config)
			config = {};
		this.config = config;
		
		if (!this.config.hideMode)
			this.config.hideMode = "close";
		
		if (!document.wbsPopmenuClickLinked) {
			addHandler(document,'click',wbsPopmenuOnDocumentClick,false);
			document.wbsPopmenuClickLinked = true;
		}
		
		var elem = document.createElement("div");
		elem.style.position = "absolute";
		$(elem).addClass(this.getWindowCls());
		$(elem).css({'z-index': 500});
		
		if (config.cls)
			$(elem).addClass(config.cls);
		
		if (config.width)
			elem.style.width = config.width + "px"
		else if (!config.cls)
			elem.style.width = "auto";
		
		if (config.height)
			elem.style.height = config.height + "px"

		this.elem = elem;
	},
		
	getWindowCls: function() {
		return "wbs-popwindow";
	},
			
	render: function() {
	},
			
		
	show: function (e) {
		if(document.wbsPopmenuCurrent != null)
			document.wbsPopmenuCurrent.close();
		this.render();
		//document.wbsPopmenuShowProcess = true;
		
		e = e || window.event;
		
		if(e.stopPropagation) e.stopPropagation();
		else e.cancelBubble = true;
			
		var target = e.target||e.srcElement;

		var targetPos = getAbsolutePos(target);
		
		var left = targetPos.x;
		var top = targetPos.y;
		
	
		
		//elem.style.top = cursorPos.y;
		var elem = this.elem;
		elem.style.top = top + target.offsetHeight + "px";
		elem.style.left = left + "px";
/**		
		if (this.config.scroll) 
		$(this.config.scroll).scroll(function () {
			var targetPos = getAbsolutePos(target);
			var left = targetPos.x;
			var top = targetPos.y;
			
			if (top + target.offsetHeight + $(elem).height() <= $(document).height()) {
				$(elem).show();
				elem.style.top = top + target.offsetHeight + "px";
				elem.style.left = left + "px";
			} else {
				$(elem).hide();
			}
		});		
*/
		document.body.appendChild(elem);
		elem.style.visibility = "visible";
		
		document.wbsPopmenuCurrent = this;
		
		if (left + elem.offsetWidth > $(document).width()) {
			elem.style.left = ($(document).width() - elem.offsetWidth-20) + "px";
		}
		if (top + elem.offsetHeight + $(elem).height() > $(document).height()) {
			var newTop = top - elem.offsetHeight;
			if (newTop > 0)
				elem.style.top = newTop + "px";
		}
		
		
		if (this.onAfterShow)
			this.onAfterShow(e);
	},
		
	hide: function() {
		throw "Not implement hide method";		
	},
	
	close: function() {
		if (this.onClose)
			this.onClose();
		
		var elem = this.elem;
		elem.style.visibility = "hidden";
		document.wbsPopmenuCurrent = null;
		elem.parentNode.removeChild(elem);
		delete elem;
		//delete this;
	},
	
	getElem: function () {
		return this.elem;
	},
		
	getInnerElem: function() {
		if (this.innerElem)
			return this.innerElem;
		
		this.innerElem = createDiv("wbs-popwindow-inner");
		this.getElem().appendChild(this.innerElem);
		return this.innerElem;
	}
});

function wbsPopmenuOnDocumentClick(e){
	if (!document.wbsPopmenuCurrent)
		return;
	/*if (document.wbsPopmenuShowProcess) {
		document.wbsPopmenuShowProcess = false;
		return;
	}*/
	e=e||event;
  var target=e.target||e.srcElement;
  var menuElem = document.wbsPopmenuCurrent.getElem();
  if(menuElem){
    var parent=target;
    while(parent.parentNode&&parent!=menuElem)
    	parent=parent.parentNode;
    if(!parent || parent != menuElem)
      document.wbsPopmenuCurrent.close();
  }
}

WbsPopmenu = newClass(WbsPopwindow, {
	constructor: function (config) {
		this.items = new Array ();
		this.superclass().constructor.call(this, config);
		this.isPd = config.isPd;
	},
		
	render: function() {
		
		var ul = document.createElement("ul");
		for (var i = 0; i < this.config.items.length; i++) {
			var item = this.config.items[i];
			
			var li = this.createItem(item);
			if (item.id) 
				this.items[item.id] = li;
			else
				this.items[this.items.length] = li;
			
			ul.appendChild(li);
		}
		this.elem.appendChild(ul);
	},
		
	getWindowCls: function() {
		if (this.config.withImages)
			return "wbs-popmenu wbs-popmenu-images";
		else
			return "wbs-popmenu";
	},
	
	getItem: function(id) {
		return this.items[id];
	},
	
	setItems: function(items) {
		this.config.items = items;
	},
	
	refreshItem: function (li, item) {
		var newLi = this.createItem(item);
		if (item.id)
			this.items[item.id] = li;
		li.parentNode.replaceChild(newLi, li);
	},
	
	hideItem: function (id) {
		$(this.items[id]).addClass("hidden");
	},
	
	showItem: function (id) {
		$(this.items[id]).removeClass("hidden");
	},
	
	createItem: function(item) {
		var li = document.createElement("li");
		if (item.cls)
			$(li).addClass(item.cls);
		
		if (item.iconCls) {
			$(li).addClass("with-image").addClass(item.iconCls);
		}
		
		if (item == "-") {
			li.className = "separator";
			li.innerHTML = "<div></div>";
		} else if (item.html) {
			li.innerHTML = item.html;
		} else {
			var anchor = document.createElement("a");
			anchor.href = "javascript:void(0)";
			var text = document.createTextNode(item.label);
			anchor.appendChild(text);
			li.appendChild(anchor);
			
			if (!item.hidden) {
				if (this.isPd)
					$(li).append('<img src="../common/html/res/images/s.gif" width="1" height="1" />');
				else
					$(li).append('<img src="../common/html/res/images/s.gif" width="1" height="1" />');
			}
				
		}
		
		if (item.onClick && !item.disabled) {
			li.onclick = function(item) {
				return function() {
					var scope = item.scope ? item.scope : this;
					var val = item.onClick.bind(scope)();
					if (!item.onClickNoHide)
						this.close();
					return val;
				};
			} (item).bind(this);
		}
		
		li.onmouseover = function() {
			if (!this.disabled)
				$(this).addClass("highlight");
		}
		li.onmouseout = function() {
			if (!this.disabled)
				$(this).removeClass("highlight");
		}
		
		if(item.hidden) {
			$(li).addClass("hidden");
		}
		if(item.disabled) {
			$(li).addClass("disabled");
			li.disabled = true;
		}
		li.setText = function(text) {this.innerHTML = text;}
		return li;
	}
});


WbsButton = newClass (null, {
	constructor: function(config) {
		this.config = config;
		this.disabled = false;
		if (!this.cls)
			this.cls = "wbs-btn";
		this.render();
	},
	
	build: function(mainElem, advElem) {
		this.btnElem.appendChild(advElem);
		this.btnElem.appendChild(mainElem);
	},
		
	setDisplayed: function (value) {
		this.btnElem.style.display = (value != false) ? "" : "none";
	},
	
	render: function() {
		var contentElem = this.getContentElem();
		
		var btnElem = createDiv(this.cls);
		this.btnElem = btnElem;
		
		var advElem = createDiv("wbs-btn-adv");
		var mainElem = createElem("a", "wbs-btn-content");
		mainElem.setAttribute("href", "javascript:void(0)");
		
		if (this.config.iconUrl) {
			mainElem.style.backgroundImage = "URL(" + this.config.iconUrl + ")";
			$(mainElem).addClass("wbs-btn-withicon");
		}
		
		if (this.config.advIconUrl) {
			advElem.style.backgroundImage = "URL(" + this.config.advIconUrl + ")";
			$(advElem).addClass("wbs-btn-left-icon");
		}
		
		var label = this.config.label;
		if (!label && contentElem.value)
			label = contentElem.value;
		if (!label)
			label = "";
		mainElem.innerHTML = label;
		this.build(mainElem, advElem);
		
		if(this.config.onClick)
			addHandler(btnElem, "click", this.onClick, this);
		
		contentElem.parentNode.replaceChild(btnElem, contentElem);
	},
	
	getContentElem: function() {
		var contentElem = document.getElementById(this.config.el);
		if (!contentElem )
			throw "No content element for WbsButton: " + this.config.el;
		return contentElem;		
	},
		
	getElem: function() {
		return this.btnElem;
	},
		
	onClick: function(e) {
		if (this.disabled)
			return false;
		if (this.config.onClick)
			this.config.onClick(e);
	},
		
	setDisabled: function(value) {
		this.disabled = value;
		if (value)
			$(this.btnElem).addClass("wbs-btn-disabled");
		else
			$(this.btnElem).removeClass("wbs-btn-disabled");
	},
		
	disable: function() {
		this.setDisabled(true);
	}, 
		
	enable: function() {
		this.setDisabled(false);
	}
});

WbsLinkButton = newClass(WbsButton, {
	constructor: function (config) {
		this.cls = "wbs-link-btn";
		this.superclass().constructor.call(this,config);	
	},
	
	build: function(mainElem, advElem) {
		this.btnElem.appendChild(mainElem);
	}	
});

WbsMenuButton = newClass(WbsButton, {
	constructor: function (config) {
		this.cls = "wbs-menu-btn";
		this.superclass().constructor.call(this,config);	
		
		if (this.config.getMenu)
			addHandler(this.btnElem, "click", function(e) {
				var getMenu = (this.config.scope) ? this.config.getMenu.bind(this.config.scope) : this.config.getMenu;
					
				var menu = getMenu(e);
				if (menu) {
					menu.show(e);
				}
			}
			, this);
	},
	
	build: function(mainElem, advElem) {
		this.btnElem.appendChild(mainElem);
		this.btnElem.appendChild(advElem);
	}
});


WbsFlexContainer = newClass (null, {
	constructor: function (config) {
		this.config = config;
		this.contentElem = config.contentElem;
		this.elem = config.elem;
		if (!this.contentElem)
			throw "No exists content elem for WbsFlexContainer";
		this.elem.addClass("wbs-flexcontainer");
		this.childElems = new Array ();
		
		this.buildPage();
		
		var fn = this.resize.bind(this);

		$(document).ready(fn);
		$(window).resize(fn);
		
	},
	
	addChildElem: function(childElem) {
		this.childElems[this.childElems.length] = childElem;
	},
	
	buildPage: function () {
		if (this.config.headerElem) {
			this.config.headerElem.addClass("wbs-flexcontainer-header");
			this.addChildElem(this.config.headerElem);
		}		
		
		this.contentElem.addClass("wbs-flexcontainer-content");
		this.addChildElem(this.contentElem);
		
		if (this.config.footerElem) {
			this.contentElem.addClass("wbs-flexcontainer-footer");
			this.addChildElem(this.config.footerElem);
		}
	},
	
	resize: function () {
		var minusHeight = 0;
		for (var i = 0; i < this.childElems.length; i++) {
			var childElem = this.childElems[i];
			if (childElem == this.contentElem)
				continue;
			minusHeight += childElem.outerHeight();
		}
		this.elem.height($(window).height() - minusHeight);
		this.contentElem.height(this.elem.height());
	}
});

WbsViewmodeSelector = newClass(WbsObservable, {
	constructor: function (table, config) {
		this.renderElem = config.elem;
		this.rendered = false;
		this.table = table;
		if (config.modes) this.modes = config.modes;
		else this.modes = new Array ("columns", "list", "detail", "tile");
		
		modeSelector = this;
		this.modesElems = {};
		this.onclick = null;
		
		
		this.superclass().constructor.call(this);
		
		this.addEvents ({
			"viewmodeChanged"	: true
		});
	},
	
	render: function() {
		this.container = document.createElement("div");
		this.container.className = "viewmode-selector";
		
		for (var i = 0; i < this.modes.length; i++) {
			var elem = this.createModeElem(this.modes[i]);
			this.container.appendChild(elem);
		}
		this.renderElem.appendChild(this.container);
		this.rendered = true;
	},
	
	setSelectedElem: function(modeElem) {
		if (this.selectedModeElem != null) {
			removeClass(this.selectedModeElem, "selected");
			this.selectedModeElem.img.src = this.getModeImgSrc(this.selectedModeElem.mode, false);
		}
		if (!modeElem)
			return;
		addClass(modeElem, "selected");
		modeElem.img.src = this.getModeImgSrc(modeElem.mode, true);
		this.selectedModeElem = modeElem;
	},
	
	getModeImgSrc: function(mode, selected) {
		var addPart = (selected) ? "_on" : "";		
		return ("../../common/templates/img/viewmode_" + mode + addPart + ".gif");
	},
		
	isRendered: function() {
		return this.rendered;
	},
		
	selectMode: function(mode) {
		this.setMode(mode);
		this.fireEvent("viewmodeChanged", mode);
	},
		
	setMode: function(mode) {
		this.selectedMode = mode;
		if (this.isRendered())
			this.setSelectedElem(this.modesElems[mode]);
		if (this.table)
			this.table.setViewMode(mode);
		if (this.onClick)
			this.onClick(this, mode);
	},
		
	setTable: function(table) {
		this.table = table;
		this.setMode(this.selectedMode);
	},
	
	
	createModeElem: function(mode) {
		var modeElem = createDiv("mode-elem");
		
		this.modesElems[mode] = modeElem;
		modeElem.mode = mode;
		modeElem.img = createElem("img");
		modeElem.img.src = this.getModeImgSrc(mode);
		modeElem.appendChild(modeElem.img);
		if (mode == this.selectedMode) {
			this.setSelectedElem(modeElem);
		}
		
		var table = this.table;
		modeElem.onclick = function () {
			modeSelector.selectMode(mode);
		};
		return modeElem;
	}
});
/**
 * Ajax upload plugin for jQuery
 * Project page - http://valums.com/ajax-upload/
 * Copyright (c) 2008 Andris Valums, http://valums.com
 * Licensed under the MIT license (http://valums.com/mit-license/)
 */
(function($){
	// we need jQuery to run
	if ( ! $) return;

	/**
	 * Function generates unique id
	 */		
	var get_uid = function(){
		var uid = 0;
		return function(){
			return uid++;
		}
	}();

	/**
	 * button - jQuery element
	 * option - hash of options :
	 *   action - URL which iframe will use to post data
	 *   name - file input name
	 *   data - extra data hash to post within the file
	 *   onSubmit - callback to fire on file submit
	 *   onComplete - callback to fire when iframe has finished loading
	 */
	window.Ajax_upload = function(button, options){
		// make sure it is jquery object
		button = $(button);
		
		if (button.size() != 1 ){
			//console.error('You passed ', button.size(),' elements to ajax_upload at once');
			return false;
		}
				
		this.button = button;
				
		this.wrapper = null;
		this.form = null;
		this.input = null;
		this.iframe = null;		

		this.disabled = false;
		this.submitting = false;
				
		this.settings = {
			// Location of the server-side upload script
			action: 'upload.php',			
			// File upload name
			name: 'userfile',
			// Additional data to send
			data: {},
			// Callback to fire when user selects file
			// You can return false to cancel upload
			onSubmit: function(file, extension) {},
			// Fired when file upload is completed
			onComplete: function(file, response) {},
			width: 0,
			height: 0,
			flt: "left"
		};

		// Merge the users options with our defaults	
		$.extend(this.settings, options);
		
		this.create_wrapper();
		this.create_input();
		
		if (jQuery.browser.msie){
			// fix ie transparent background bug
			this.make_parent_opaque();
		}
		
		this.create_iframe();		
	}
	
	// assigning methods to our class
	Ajax_upload.prototype = {
		set_data : function(data){
			this.settings.data = data;
		},
		disable : function(){
			this.disabled = true;
			if ( ! this.submitting){
				this.input.attr('disabled', true);
				this.button.removeClass('hover');	
			}			
		},
		enable : function(){
			this.disabled = false;
			this.input.attr('disabled', false);							
		},
		/**
		 * Creates wrapper for button and invisible file input
		 */
		create_wrapper : function(){
			// Shorten names			
			var button = this.button, wrapper;
			
			wrapper = this.wrapper = $('<span></span>')
				.insertAfter(button)
				.append(button);			

			// wait a bit because of FF bug
			// it can't properly calculate the outerHeight

			var self = this;
			setTimeout(function(){
				wrapper.css({
					'float': self.settings.flt,
					position: 'relative',
					overflow: 'hidden',
					display: 'block',
					margin: 0,
					padding: 0,
					// we need dimensions because of ie bug that allows to move 
					// input outside even if overflow set to hidden					

					height: self.settings.height ? self.settings.height : button.outerHeight(true),
					width: self.settings.width ? self.settings.width : button.outerWidth(true)
				});				
			}, 1);
			
			wrapper.mousemove(function(e){
				// Move the input with the mouse, so the user can't misclick it
				if (!self.input ) {
					return;
				}
									
				self.input.css({
					top: e.pageY - wrapper.offset().top - 5 + 'px'
					,left: e.pageX - wrapper.offset().left - 1 + 'px'
				});
			});

	
		},
		/**
		 * Creates invisible file input above the button 
		 */
		create_input : function(){
			var self = this;

			this.input = $('<input type="file" />')
				.attr('name', this.settings.name)				
				.css({'position' : 'absolute', 'margin': "0", 'padding': "0", 'width': '2px', 'height': '10px', 'opacity': 0})
				.change(function(){
					if ($(this).val() == ''){
						// there is no file
						return;
					}
					
					// we need to lock "disable" method
					self.submitting = true;
					
					// Submit form when value is changed
					self.submit();
					
					if (self.disabled){
						self.disable();					
					}						
					// unlock "disable" method
					self.submitting = false;					
				})
				.appendTo(this.wrapper)
				
				// Emulate button hover effect				
				.hover(
					function(){
						if (self.settings.hover) {
							self.settings.hover();
						}
						self.button.addClass('hover');
					}, function(){
						if (self.settings.unhover) {
							self.settings.unhover();
						}
						self.button.removeClass('hover');
					}
				);
				
			if (this.disabled){
				this.input.attr('disabled', true);
			}

		},
		/**
		 * Creates iframe with unique name
		 */
		create_iframe : function(){
			// unique name
			// We cannot use getTime, because it sometimes return
			// same value in safari :(
			var id = 'valums97hhu' + get_uid();
			
			// create iframe, so we dont need to refresh page
			this.iframe = 
				$('<iframe id="' + id + '" name="' + id + '"></iframe>')
				.css('display', 'none')
				.appendTo('body');									
		},
		/**
		 * Upload file without refreshing the page
		 */
		submit : function(){			
			var self = this, settings = this.settings;			
			
			// get filename from input
			var file = this.file_from_path(this.input.val());			

			// execute user event
			if (settings.onSubmit.call(this, file, this.get_ext(file)) === false){
				// Do not continue if user function returns false						
				return;
			}			

			this.create_form();
			this.input.appendTo(this.form);			
			this.form.submit();			
			
			this.input.remove(); this.input = null;
			this.form.remove();	this.form = null;

			this.submitting = false;
			
			// create new input
			this.create_input();	
	
			var iframe = this.iframe;
			iframe.load(function(){
				var response = iframe.contents().find('body').html();	
		
				settings.onComplete.call(self, file, response);				
				/// Workaround for FF2 bug, which causes cursor to be in busy state after post.
				setTimeout(function(){
					iframe.remove();
				}, 1);				
			});
			
			// Create new iframe, so we can have multiple uploads at once
			this.create_iframe();		
		},		
		/**
		 * Creates form, that will be submitted to iframe
		 */
		create_form : function(){
			// method, enctype must be specified here
			// because changing this attr on the fly is not allowed in IE 6/7
			this.form = 
				$('<form method="post" enctype="multipart/form-data"></form>')				
				.attr({
					"action" : this.settings.action
					,"target" : this.iframe.attr('name')					
				})
				.appendTo('body');			
			
			// Create hidden input element for each data key
			for (var i in this.settings.data){
				$('<input type="hidden" />')
					.appendTo(this.form)
					.attr({
						'name': i
						,'value': this.settings.data[i]
					});
			}
		},		
		file_from_path : function(file){
			return file.replace(/.*(\/|\\)/, "");			
		},
		get_ext : function(file){
			return (/[.]/.exec(file)) ? /[^.]+$/.exec(file.toLowerCase()) : '';
		},
		make_parent_opaque : function(){
			// ie transparent background bug
			this.button.add(this.button.parents()).each(function(){				
				var color = $(this).css('backgroundColor');
				var image = $(this).css('backgroundImage');
	
				if ( color != 'transparent' ||  image != 'none'){
					//$(this).css('opacity', 1);
					return false;
				}
			});			
		}
		
	};
})(jQuery);
